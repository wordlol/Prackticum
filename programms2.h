#pragma once
#include "Header.h"
using namespace std;

//1 этап
void FirstCode()
{	//консоль
	std::cout << "Hello World!!!";
}

void Operators()
{	//операторы
	int a = 14;
	int b = 5;

	int c = a+b;
	int d = a-b;
	int e = a*b;
	int z = a / b;
	int f = a%b;


	std::cout << "значение a " << a << "\n";
	std::cout << "значение b " << b << "\n";
	std::cout<< "сумма " << c << "\n";
	std::cout << "разность " << d << "\n";
	std::cout << "произведение " << e << "\n";
	std::cout << "частное " << z << "\n";
	std::cout << "остаток " << f << "\n";
}

void Logic()
{	//логика if else
	int Age;
	std::cout << "Ведите возраст: " << endl;
	std::cin >> Age;

	if (Age < 18)
	{
		std::cout << "Вас не пустят в клуб" << endl;
	}
	else
	{
		std::cout << "Вы проходите" << endl;
	}
}

void WhatNumber()
{	//угадай число
	//for, srand(), rand
	int TempRand = 0;
	srand(TempRand);
	int input;
	std::cout << "угадай число в диапозоне от 0 до 10\n";
	for (int i = 0; i < 10; i++)
	{
		int RandNumber = rand();
		std::cin >> input;
		if (input == RandNumber % 10)
		{
			srand(TempRand);
			TempRand = input;
			std::cout << "ты угадал\n";
		}
		else
		{
			srand(TempRand);
			std::cout << "попробуй еще\n";
		}

	}
}

void WhatWord()
{
	/*Программа должна принимать на вход строку текста, и распознавать 
		введенный вариант ответа.Используйте английский язык для текста.
		Также необходимо провести валидацию*/
	//string
	string input;
	string Words[3]{"rock","scissors","paper"};
	std::cout << "найди слово\n";
	for (int i = 0; i < 10; i++)
	{
		std::cin >> input;
		for (int j = 0; j < sizeof(Words)/sizeof(Words[0]); j++)
		{
			if (input == Words[j])
			{
				std::cout << "ты нашел это слово\n";
				break;
			}
			else if (j == sizeof(Words) / sizeof(Words[0]) - 1 && input!= Words[j])
			{
				std::cout << "такого слова нет попробуй снова\n";
			}
		}
	}
}

void StoreGoods()
{
	/*Требуется произвести следующие расчеты :
	1.имеются ли в наличии товары которые хочет купить пользователь
		2.хватит ли денег для приобретения товаров из списка
		3.сколько денег останется после совершения покупок
		Дополнительно, программа должна дать ответы на вопросы :
	1.каким должен быть список покупок, чтобы потратить максимальное количество денег
		каким должен быть список покупок, чтобы купить максимальное число товаров*/
	//конец 1 этапа закрепление материала

	string NameGoods[]{ "огурец", "помидор", "лук", "картофель", "морковь" };
	const int Size = sizeof(NameGoods) / sizeof(NameGoods[0]);
	int CurentGoods[Size]{ 15, 20, 10, 4, 20 };
	int PriceList[Size]{ 30,50,20,150,60 };
	int Money;
	std::cout << "количество денег: ";
	std::cin >> Money;
	std::cout << "ассортимент товаров:\n";
	for (int i = 0; i < Size; i++)
	{
		std::cout << NameGoods[i] << " - ";
		std::cout << CurentGoods[i] << " штук; ";
		std::cout << PriceList[i] << " Цена за штуку; ";
		std::cout << i << " ID товара\n";
	}
	std::cout << "\n";
	std::cout << "список покупок на все ваши деньги: \n";
	for (int i = 0; i < Size; i++)
	{
		if (PriceList[i] <= Money)
		{
			std::cout << NameGoods[i] << " хватает на " << Money / PriceList[i] << " Штуки" << endl;
		}
		else
		{
			std::cout << "на " << NameGoods[i] << " не хватит денег" << endl;
		}
	}

	std::cout << "\n укажи какие товары хочешь купить и их количество\n";
	int InputCount;
	int InputIDName;
	int sizeGoods;
	std::cout << "укажите сколько товаров собираетесь купить: ";
	std::cin >> sizeGoods;
	int FullCount;
	for (int i = 0; i < sizeGoods; i++)
	{
		std::cout << "укажите ID товара: ";
		std::cin >> InputIDName;
		for (int j = 0; j < Size; j++)
		{
			if (j == InputIDName)
			{
				std::cout << "количество: ";
				std::cin >> InputCount;
				std::cout << "товар: ";
				std::cout << NameGoods[j] << endl;
				if (CurentGoods[j] >= InputCount && CurentGoods[j] != 0)
				{
					std::cout << "товар имеется в наличии\n ";
					FullCount = InputCount;
				}
				else if (CurentGoods[j] == 0)
				{
					std::cout << "на складе нету этого товара\n ";
				}
				else if (CurentGoods[j] < InputCount)
				{
					std::cout << "на складе есть только: " << CurentGoods[j] << " ед.товара\n";
					FullCount = CurentGoods[j];
				}

				std::cout << "цена за товар: " << FullCount * PriceList[j] << endl;
				if (FullCount * PriceList[j] > Money)
				{
					std::cout << "у вам не хватает денег\n ";
					break;
				}
				else
				{
					Money -= FullCount * PriceList[j];
					std::cout << "после покупки у нас на счету останется: " << Money << endl;
				}
			}
		}
	}
}


//2 этап
void TextAdvacuresLocation()
{
	///Переход по локациям любым
	//struct
	struct Location
	{
		std::string NameLvl;
		bool player = false;
	}Locations[5];

	Locations[0].NameLvl = "swamp";
	Locations[1].NameLvl = "city";
	Locations[2].NameLvl = "forest";
	Locations[3].NameLvl = "cave";
	Locations[4].NameLvl = "river";
	string Input;

	while (true)
	{
		system("cls");
		for (int i = 0; i < sizeof(Locations)/ sizeof(Locations[0]); i++)
		{
			std::cout << "локация: " << Locations[i].NameLvl << endl;
			if (Locations[i].player == true)
			{
				Locations[i].player = false;
				std::cout << " ^ ты на этой локации\n";
			}
		}

		std::cout << "\nна какую локацию переместится?: ";
		std::cin >> Input;

		for (int i = 0; i < sizeof(Locations) / sizeof(Locations[0]); i++)
		{
			if (Input == Locations[i].NameLvl)
			{
				std::cout << "Вы переместились на локацию локацию: " << Locations[i].NameLvl<< endl;
				Locations[i].player = true;
				break;
			}
		}
		system("pause");
		system("cls");
	};
}

void TextAdvacuresDoor()
{///Переход по локациям через дверь
	//push_back
	struct Location
	{
		std::vector<int> doors;
		std::string NameLvl;
		bool player = false;
	}Locations[5];

	Locations[0].NameLvl = "swamp";
	Locations[0].doors.push_back(1);
	Locations[0].doors.push_back(2);
	Locations[0].player = true;

	Locations[1].NameLvl = "city";
	Locations[1].doors.push_back(0);
	Locations[1].doors.push_back(3);

	Locations[2].NameLvl = "forest";
	Locations[2].doors.push_back(0);
	Locations[2].doors.push_back(4);

	Locations[3].NameLvl = "cave";
	Locations[3].doors.push_back(1);
	Locations[3].doors.push_back(4);

	Locations[4].NameLvl = "river";
	Locations[4].doors.push_back(2);
	Locations[4].doors.push_back(3);

	string Input;

	while (true)
	{
		system("cls");
		for (int i = 0; i < sizeof(Locations) / sizeof(Locations[0]); i++)
		{
			if (Locations[i].player == true)
			{
				std::cout << "локация: " << Locations[i].NameLvl << endl;
				Locations[i].player = false;
				std::cout << " ^ ты на этой локации\n";
				std::cout << "\nты можешь переместиться только на эти локации\n";
				for (int j = 0; j < Locations[i].doors.size(); j++)
				{
					std::cout << "локация: " << Locations[Locations[i].doors[j]].NameLvl << endl;
				}
			}
		}

		std::cout << "\nна какую локацию переместится?: ";
		std::cin >> Input;

		for (int i = 0; i < sizeof(Locations) / sizeof(Locations[0]); i++)
		{
			if (Input == Locations[i].NameLvl)
			{
				std::cout << "Вы переместились на локацию локацию: " << Locations[i].NameLvl << endl;
				Locations[i].player = true;
				break;
			}
		}
		system("pause");
		system("cls");
	};
}

void TextAdvacuresItems()
{///Добавление функционала
	/*  List - показать все предметы, находящиеся в локации
		Trunk - показать все предметы в “рюкзаке” игрока
		Pick(название предмета) - поднять предмет и положить его в рюкзак игрока
		Drop(название предмета) - сбросить предмет из рюкзака в локацию
		Use(название предмета 1, название предмета 2) - использовать предмет(например - ключ на двери)*/
	//erase

	class enemy
	{
	public:
		int hp = 100;
		int damage = 30;
		int defence = 10;
	}*Enemy;

	struct ListItems {

		std::string sword = "sword", heal = "heal", armor = "armor", stick = "stick", food = "food", bag = "bag", campfire = "campfire", wood = "wood", stone = "stone", chest = "chest", key = "key";
	}ListItems_;

	struct Objects
	{
		std::vector<std::string> ItemsInLocation;
		std::vector<enemy*> EnemyInLocation;
	}*Object;

	struct Location
	{
		std::vector<int> doors;
		std::string NameLvl;
		std::vector<Objects*> ObjectInLocation;
		bool player = false;
	}Locations[5];

	int tempLocation = 0;

	Locations[0].NameLvl = "swamp";
	Locations[0].doors.push_back(1);
	Locations[0].doors.push_back(2);
	Locations[0].player = true;
	vector<std::string> BackPack;

	Locations[0].ObjectInLocation.push_back(Object = new Objects);
	Locations[0].ObjectInLocation.back()->EnemyInLocation.push_back(Enemy = new enemy);
	Locations[0].ObjectInLocation.back()->EnemyInLocation.push_back(Enemy = new enemy);
	Locations[0].ObjectInLocation.back()->EnemyInLocation.push_back(Enemy = new enemy);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.stone);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.campfire);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.bag);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.heal);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.heal);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.sword);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.food);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.armor);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.chest);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.key);

	Locations[1].NameLvl = "city";
	Locations[1].doors.push_back(0);
	Locations[1].doors.push_back(3);

	Locations[2].NameLvl = "forest";
	Locations[2].doors.push_back(0);
	Locations[2].doors.push_back(4);

	Locations[3].NameLvl = "cave";
	Locations[3].doors.push_back(1);
	Locations[3].doors.push_back(4);

	Locations[4].NameLvl = "river";
	Locations[4].doors.push_back(2);
	Locations[4].doors.push_back(3);

	string Input;

	while (true)
	{
		system("cls");
		for (int i = 0; i < sizeof(Locations) / sizeof(Locations[0]); i++)
		{
			if (Locations[i].player == true)
			{
				std::cout << "локация: " << Locations[i].NameLvl << endl;
				Locations[i].player = false;
				std::cout << " ^ ты на этой локации\n";
				std::cout << "\nты можешь переместиться только на эти локации\n";
				for (int j = 0; j < Locations[i].doors.size(); j++)
				{
					std::cout << "локация: " << Locations[Locations[i].doors[j]].NameLvl << endl;
				}
			}
		}

		std::cout << "\nна какую локацию переместится?: ";
		std::cin >> Input;
		system("cls");
		for (int i = 0; i < sizeof(Locations) / sizeof(Locations[0]); i++)
		{
			if (Input == Locations[i].NameLvl)
			{
				std::cout << "Вы переместились на локацию: " << Locations[i].NameLvl << endl;
				Locations[i].player = true;
				tempLocation = i;
				break;
			}
		}
		while (true)
		{
			Objects* obj = Locations[tempLocation].ObjectInLocation.back();
			std::string input;
			std::cout << "\nЧто сделать на локации\n";
			std::cout << "\nList - показать все предметы, находящиеся в локации\n";
			std::cout << "\nTrunk - показать все предметы в “рюкзаке” игрока\n";
			std::cout << "\nPick - поднять предмет и положить его в рюкзак игрока\n";
			std::cout << "\nDrop - сбросить предмет из рюкзака в локацию\n";
			std::cout << "\nUse - использовать предмет (например - ключ на двери)\n";
			std::cout << "\nExit - уйти с локации\n";
			std::cin >> input;
			system("cls");
			if (input == "List")
			{
				for (int i = 0; i < Locations[0].ObjectInLocation.back()->ItemsInLocation.size(); i++)
				{
					std::cout << "предметы на локации: " << endl;
					std::cout << Locations[0].ObjectInLocation.back()->ItemsInLocation[i] << endl;
				}
			}
			else if (input == "Trunk")
			{
				std::cout << "предметы в рюкзаке: " << endl;
				for (int i = 0; i < BackPack.size(); i++)
				{
					std::cout << BackPack[i] << endl;
				}
				if (BackPack.size() == 0)
				{
					std::cout << "у вас нет предметов " << endl;
				}
			}
			else if (input == "Pick")
			{
				for (int i = 0; i < Locations[0].ObjectInLocation.back()->ItemsInLocation.size(); i++)
				{
					std::cout << "предметы на локации: " << endl;
					std::cout << Locations[0].ObjectInLocation.back()->ItemsInLocation[i] << endl;
				}
				std::cout <<endl<< "напиши предмет который хочешь положить в рюкзак: ";
				std::cin >> input;

				for (int i = 0; i < Locations[0].ObjectInLocation.back()->ItemsInLocation.size(); i++)
				{
					if (input == Locations[0].ObjectInLocation.back()->ItemsInLocation[i])
					{
						std::cout << endl << "Вы положили в рюкзак: "<< Locations[0].ObjectInLocation.back()->ItemsInLocation[i];
						BackPack.push_back(Locations[0].ObjectInLocation.back()->ItemsInLocation[i]);
						Locations[0].ObjectInLocation.back()->ItemsInLocation.erase(Locations[0].ObjectInLocation.back()->ItemsInLocation.begin()+i);
					}
				}
			}
			else if (input == "Drop")
			{
				std::cout << endl << "предметы в рюкзаке: " << endl;
				for (int i = 0; i < BackPack.size(); i++)
				{
					std::cout << BackPack[i] << endl;
					std::cout << endl;

					if (i == BackPack.size() - 1)
					{
						std::cout << "напиши предмет который хочешь выложить из рюкзака: ";
						std::cin >> input;
						for (int i = 0; i < BackPack.size(); i++)
						{
							if (input == BackPack[i])
							{
								std::cout << endl << "Вы выложили предмет из рюкзака: " << BackPack[i];
								Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(BackPack[i]);
								BackPack.erase(BackPack.begin()+i);
							}
						}
					}
				}
				if (BackPack.size() == 0)
				{
					std::cout <<endl<< "у вас нет предметов " << endl;
				}
			}
			else if (input == "Use")
			{
				std::cout << "предметы на локации с которыми можно взаимодействовать: " << endl;
				for (int i = 0; i < Locations[0].ObjectInLocation.back()->ItemsInLocation.size(); i++)
				{
					if (Locations[0].ObjectInLocation.back()->ItemsInLocation[i] == ListItems_.chest)
					{
						std::cout << Locations[0].ObjectInLocation.back()->ItemsInLocation[i] << endl;
					}
				}
				std::cout << endl << "предметы в рюкзаке: " << endl;
				for (int i = 0; i < BackPack.size(); i++)
				{
					if (BackPack[i] == ListItems_.key)
					{
						std::cout << BackPack[i] << endl;
					}
					if (i == BackPack.size() - 1)
					{
						std::cout << endl << "напиши предмет который хочешь использовать из рюкзака: ";
						std::cin >> input;
						for (int i = 0; i < BackPack.size(); i++)
						{
							if (input == BackPack[i])
							{
								std::cout << endl << "напиши предмет с которым ты хочешь взаимодействовать: ";
								std::cin >> input;
								for (int j = 0; j < Locations[0].ObjectInLocation.back()->ItemsInLocation.size(); j++)
								{
									if (input == Locations[0].ObjectInLocation.back()->ItemsInLocation[j])
									{
										std::cout << endl << "Вы взаимодействовали с придметом: " << Locations[0].ObjectInLocation.back()->ItemsInLocation[j];
										Locations[0].ObjectInLocation.back()->ItemsInLocation.erase(Locations[0].ObjectInLocation.back()->ItemsInLocation.begin() + j);
									}
								}
								std::cout << endl << "Вы использовали на нем предмет: " << BackPack[i];
								BackPack.erase(BackPack.begin() + i);

								//тут какая то логика
							}
						}
					}
				}
				if (BackPack.size() == 0)
				{
					std::cout<< endl << "у вас нет предметов " << endl;
				}


			}
			else if (input == "Exit")
			{
				break;
			}
			std::cout << endl;
			system("pause");
			system("cls");
		}
	};
}

void TextAdvacuresNpc()
{///Дрбавил врагов
	
	
	struct Player
	{
	public:
		int hpP = 100;
		int damageP = 30;
		float defenceP = 10;
		int countHeal = 3;
		void Healen()
		{
			if (countHeal != 0)
			{
				countHeal--;
				hpP += 20;
			}
		}
	};
	
	class enemy :public Player
	{
	public:
		int hp = 100;
		int damage = 30;
		float defence = 10;
		
		bool RandomBattle(int TempNumber)
		{
			srand(TempNumber);
			int Dice = rand()%10;
			if (Dice > 5)
			{
				system("cls");
				system("color 4");
				std::cout << "БИТВА"<<endl<<endl;
				srand(Dice); //кто бъет первый
				while (true) //битва пошаговая
				{
					int input;
					int FirstAttack = rand() % 10;
					bool EndFight;
					if (FirstAttack > 5)
					{	//первый атакует герой
						std::cout << "Вы атакуете первым"<<endl<<endl;
						std::cout << "Нажмите на номер дейсвия которое хотите сделать:" << endl;
						std::cout << "1 - Защититься ваша защита повысится на +50 на этот ход" << endl;
						std::cout << "2 - Атаковать на +"<< damageP << endl;
						std::cout << "3 - Лечение на +20"<< " осталось: "<< countHeal << endl;
						std::cin >> input;
						system("cls");
						switch (input)
						{
						case 1:
						{
							defenceP += 50;
							std::cout << "Ваша защита: " << defenceP << endl;
							system("pause");
							break;
						}
						case 2:
						{
							hp -= damageP - (damageP * (defence / 100));
							std::cout << "Вы атаковали противника у него осталось hp: " << hp << endl;
							system("pause");
							break;
						}
						case 3:
						{
							Healen();
							std::cout << "Ваши показаетли здоровья  после лечения: " << hpP << endl;
							system("pause");
							break;
						}
						default:
							break;
						}
						system("cls");
						if (hp <= 0)
						{
							std::cout << "противник повержен" << endl;
							system("pause");
							break;
						}
						else
						{
							std::cout << "Сейчас атакует враг" << endl << endl;
							hpP -= damage - (damage*(defenceP/100));
							std::cout << "у вас осталось hp: " << hpP << endl;

							if (defenceP>10)
							{
								defenceP = 10;
							}

							if (hpP <= 0)
							{
								std::cout << "игрок повержен" << endl;
								system("pause");
								system("cls");
								break;
							}
							system("pause");
							system("cls");
						}
					}
					else
					{	//первый атакует противник
						std::cout << "Сейчас атакует враг";
						hpP -= damage - (damage * (defenceP / 100));
						std::cout << "у вас осталось hp: " << hpP << endl;
						if (defenceP > 10)
						{
							defenceP = 10;
						}
						if (hpP <= 0)
						{
							std::cout << "игрок повержен" << endl;
							system("pause");
							break;
						}
						system("pause");
						system("cls");
						std::cout << "Теперь атакуете вы" << endl << endl;
						std::cout << "Нажмите на номер дейсвия которое хотите сделать:" << endl;
						std::cout << "1 - Защититься ваша защита повысится на +50 на этот ход" << endl;
						std::cout << "2 - Атаковать на +" << damageP << endl;
						std::cout << "3 - Лечение на +20" << " осталось: " << countHeal << endl;
						std::cin >> input;
						system("cls");
						switch (input)
						{
						case 1:
						{
							defenceP += 50;
							std::cout << "Ваша защита: " << defenceP << endl;
							system("pause");
							break;
						}
						case 2:
						{
							hp -= damageP - (damageP * (defence / 100));
							std::cout << "Вы атаковали противника у него осталось hp: " << hp << endl;
							system("pause");
							break;
						}
						case 3:
						{
							Healen();
							std::cout << "Ваши показаетли здоровья  после лечения: " << hpP << endl;
							system("pause");
							break;
						}
						default:
							break;
						}
						system("cls");
						if (hp <= 0)
						{
							std::cout << "противник повержен" << endl;
							system("pause");
							break;
						}


					}
				}
				system("color 0");
				system("cls");
				return true;
			}
			else
			{
				return false;
			}
		}

	}*Enemy;

	struct ListItems {

		std::string sword = "sword", heal = "heal", armor = "armor", stick = "stick", food = "food", bag = "bag", campfire = "campfire", wood = "wood", stone = "stone", chest = "chest", key = "key";
	}ListItems_;

	struct Objects
	{
		std::vector<std::string> ItemsInLocation;
		std::vector<enemy*> EnemyInLocation;
	}*Object;

	struct Location
	{
		std::vector<int> doors;
		std::string NameLvl;
		std::vector<Objects*> ObjectInLocation;
		bool player = false;
	}Locations[5];

	int tempLocation = 0;
	vector<std::string> BackPack;
	Locations[0].NameLvl = "swamp";
	Locations[0].doors.push_back(1);
	Locations[0].doors.push_back(2);
	Locations[0].player = true;
	
	Locations[0].ObjectInLocation.push_back(Object = new Objects);
	Locations[0].ObjectInLocation.back()->EnemyInLocation.push_back(Enemy = new enemy);
	Locations[0].ObjectInLocation.back()->EnemyInLocation.push_back(Enemy = new enemy);
	Locations[0].ObjectInLocation.back()->EnemyInLocation.push_back(Enemy = new enemy);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.stone);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.campfire);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.bag);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.heal);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.heal);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.sword);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.food);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.armor);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.chest);
	Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(ListItems_.key);

	Locations[1].NameLvl = "city";
	Locations[1].doors.push_back(0);
	Locations[1].doors.push_back(3);

	Locations[2].NameLvl = "forest";
	Locations[2].doors.push_back(0);
	Locations[2].doors.push_back(4);

	Locations[3].NameLvl = "cave";
	Locations[3].doors.push_back(1);
	Locations[3].doors.push_back(4);

	Locations[4].NameLvl = "river";
	Locations[4].doors.push_back(2);
	Locations[4].doors.push_back(3);

	string Input;

	while (true)
	{
		system("cls");
		for (int i = 0; i < sizeof(Locations) / sizeof(Locations[0]); i++)
		{
			if (Locations[i].player == true)
			{
				std::cout << "локация: " << Locations[i].NameLvl << endl;
				Locations[i].player = false;
				std::cout << " ^ ты на этой локации\n";
				std::cout << "\nты можешь переместиться только на эти локации\n";
				for (int j = 0; j < Locations[i].doors.size(); j++)
				{
					std::cout << "локация: " << Locations[Locations[i].doors[j]].NameLvl << endl;
				}
			}
		}
		std::cout << "\nна какую локацию переместиться?: ";
		std::cin >> Input;
		system("cls");
		for (int i = 0; i < sizeof(Locations) / sizeof(Locations[0]); i++)
		{
			if (Input == Locations[i].NameLvl)
			{
				std::cout << "Вы переместились на локацию: " << Locations[i].NameLvl << endl;
				Locations[i].player = true;
				tempLocation = i;
				break;
			}
		}
		while (true)
		{	
			int RandTemp = 0;
			for (int i = 0; i < Locations[tempLocation].ObjectInLocation.back()->EnemyInLocation.size(); i++)
			{
				if (Locations[tempLocation].ObjectInLocation.back()->EnemyInLocation[i]->RandomBattle(RandTemp))
				{
					Locations[tempLocation].ObjectInLocation.back()->EnemyInLocation.erase(Locations[tempLocation].ObjectInLocation.back()->EnemyInLocation.begin() + i);
					system("color 0");
					break;
				}
			}

			Objects* obj = Locations[tempLocation].ObjectInLocation.back();
			std::string input;
			std::cout << "\nЧто сделать на локации\n";
			std::cout << "\nList - показать все предметы, находящиеся в локации\n";
			std::cout << "\nTrunk - показать все предметы в “рюкзаке” игрока\n";
			std::cout << "\nPick - поднять предмет и положить его в рюкзак игрока\n";
			std::cout << "\nDrop - сбросить предмет из рюкзака в локацию\n";
			std::cout << "\nUse - использовать предмет (например - ключ на двери)\n";
			std::cout << "\nExit - уйти с локации\n";
			std::cin >> input;
			system("cls");
			if (input == "List")
			{
				for (int i = 0; i < Locations[0].ObjectInLocation.back()->ItemsInLocation.size(); i++)
				{
					std::cout << "предметы на локации: " << endl;
					std::cout << Locations[0].ObjectInLocation.back()->ItemsInLocation[i] << endl;
				}
			}
			else if (input == "Trunk")
			{
				std::cout << "предметы в рюкзаке: " << endl;
				for (int i = 0; i < BackPack.size(); i++)
				{
					std::cout << BackPack[i] << endl;
				}
				if (BackPack.size() == 0)
				{
					std::cout << "у вас нет предметов " << endl;
				}
			}
			else if (input == "Pick")
			{
				for (int i = 0; i < Locations[0].ObjectInLocation.back()->ItemsInLocation.size(); i++)
				{
					std::cout << "предметы на локации: " << endl;
					std::cout << Locations[0].ObjectInLocation.back()->ItemsInLocation[i] << endl;
				}
				std::cout << endl << "напиши предмет который хочешь положить в рюкзак: ";
				std::cin >> input;

				for (int i = 0; i < Locations[0].ObjectInLocation.back()->ItemsInLocation.size(); i++)
				{
					if (input == Locations[0].ObjectInLocation.back()->ItemsInLocation[i])
					{
						std::cout << endl << "Вы положили в рюкзак: " << Locations[0].ObjectInLocation.back()->ItemsInLocation[i];
						BackPack.push_back(Locations[0].ObjectInLocation.back()->ItemsInLocation[i]);
						Locations[0].ObjectInLocation.back()->ItemsInLocation.erase(Locations[0].ObjectInLocation.back()->ItemsInLocation.begin() + i);
					}
				}
			}
			else if (input == "Drop")
			{
				std::cout << endl << "предметы в рюкзаке: " << endl;
				for (int i = 0; i < BackPack.size(); i++)
				{
					std::cout << BackPack[i] << endl;
					std::cout << endl;

					if (i == BackPack.size() - 1)
					{
						std::cout << "напиши предмет который хочешь выложить из рюкзака: ";
						std::cin >> input;
						for (int i = 0; i < BackPack.size(); i++)
						{
							if (input == BackPack[i])
							{
								std::cout << endl << "Вы выложили предмет из рюкзака: " << BackPack[i];
								Locations[0].ObjectInLocation.back()->ItemsInLocation.push_back(BackPack[i]);
								BackPack.erase(BackPack.begin() + i);
							}
						}
					}
				}
				if (BackPack.size() == 0)
				{
					std::cout << endl << "у вас нет предметов " << endl;
				}
			}
			else if (input == "Use")
			{
				std::cout << "предметы на локации с которыми можно взаимодействовать: " << endl;
				for (int i = 0; i < Locations[0].ObjectInLocation.back()->ItemsInLocation.size(); i++)
				{
					if (Locations[0].ObjectInLocation.back()->ItemsInLocation[i] == ListItems_.chest)
					{
						std::cout << Locations[0].ObjectInLocation.back()->ItemsInLocation[i] << endl;
					}
				}
				std::cout << endl << "предметы в рюкзаке: " << endl;
				for (int i = 0; i < BackPack.size(); i++)
				{
					if (BackPack[i] == ListItems_.key)
					{
						std::cout << BackPack[i] << endl;
					}
					if (i == BackPack.size() - 1)
					{
						std::cout << endl << "напиши предмет который хочешь использовать из рюкзака: ";
						std::cin >> input;
						for (int i = 0; i < BackPack.size(); i++)
						{
							if (input == BackPack[i])
							{
								std::cout << endl << "напиши предмет с которым ты хочешь взаимодействовать: ";
								std::cin >> input;
								for (int j = 0; j < Locations[0].ObjectInLocation.back()->ItemsInLocation.size(); j++)
								{
									if (input == Locations[0].ObjectInLocation.back()->ItemsInLocation[j])
									{
										std::cout << endl << "Вы взаимодействовали с придметом: " << Locations[0].ObjectInLocation.back()->ItemsInLocation[j];
										Locations[0].ObjectInLocation.back()->ItemsInLocation.erase(Locations[0].ObjectInLocation.back()->ItemsInLocation.begin() + j);
									}
								}
								std::cout << endl << "Вы использовали на нем предмет: " << BackPack[i];
								BackPack.erase(BackPack.begin() + i);

								//тут какая то логика
							}
						}
					}
				}
				if (BackPack.size() == 0)
				{
					std::cout << endl << "у вас нет предметов " << endl;
				}


			}
			else if (input == "Exit")
			{
				break;
			}
			std::cout << endl;
			system("pause");
			system("cls");
			RandTemp++;
		}
	};
}